<?
# ----------------------------------- Python -----------------------------------
# ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
# ------------------------------------------------------------------------------

# Imports
import numpy as np
from warnings import warn

# Set default keys
default_keys = {'min_mesh_angle' : 20.,
				'refine_all_circle' : 2,
				'uol' : 1.e-9,
				'pore_angle' : 0.}

for dkey, dval in default_keys.iteritems():
	if not dkey in keys:
		keys[dkey] = dval

# Maximum side length keys
max_sl_keys = ['max_sl_circle', 'max_sl_polygon', 
               'max_sl_z_slab', 'max_sl_z_sub',
               'max_sl_z_sup']

# Set maximum side lengths using the 'slc_wvl_ratio' if set
if 'slc_wvl_ratio' in keys:
    slc_wvl_r = keys['slc_wvl_ratio']
    for _k in max_sl_keys:
        if _k in keys:
            warn("key 'slc_wvl_ratio' overwrides settings for '"+_k+"'")
    
    # Calculate the resulting maximum side length in air
    wvl = keys['vacuum_wavelength']
    slc_air = slc_wvl_r * wvl / keys['uol']
    
    # Load the refractive indices
    n_sub = np.real(keys['mat_subspace'].getNKdata(wvl))
    n_super = np.real(keys['mat_superspace'].getNKdata(wvl))
    n_phc = np.real(keys['mat_phc'].getNKdata(wvl))
    
    # The slab region consists of two materials: the PhC-material
    # and the superspace-material. The maximum side length in
    # z-direction must hence be set using the maximum of both
    # refractive indices
    n_slab_max = max([n_phc, n_super])
    
    # Set the resulting maximum side lengths using the material
    # properties
    keys['max_sl_circle'] = slc_air/n_super
    keys['max_sl_polygon'] = slc_air/n_phc
    keys['max_sl_z_slab'] = slc_air/n_slab_max
    keys['max_sl_z_sub'] = slc_air/n_sub
    keys['max_sl_z_sup'] = slc_air/n_super

# Set all missing values for the z-direction maximum side lengths using
# the minimum of the two horizontal side lengths
sl_z_default = min([keys['max_sl_polygon'], keys['max_sl_circle']])
sl_z_keys = ['max_sl_z_sub', 'max_sl_z_slab', 'max_sl_z_sup']
for zkey in sl_z_keys:
	if not zkey in keys:
		keys[zkey] = sl_z_default

# Calculate the lower and upper radii of the cone from center diameter and
# pore angle
alpha = keys['pore_angle']
d = keys['d']
h = keys['h']
keys['radius_i'] = d/2. - h*np.tan(np.deg2rad(alpha))/2.
keys['radius_f'] = keys['d'] - keys['radius_i']

# ------------------------------------------------------------------------------
# ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
# ------------------------------------------------------------------------------
?>
Layout {
  UnitOfLength = %(uol)e
  MeshOptions {
    MinimumMeshAngle = %(min_mesh_angle)4f
  }

  Polygon { 
    Name = "ComputationalDomain" 
    DomainId = 1
    Priority = -1 
    PeriodicUnitCell {
      LatticeVectorLengths = [%(p)4f %(p)4f]
      LatticeAngle = 60
      Shape = Hexagonal
    }
    MeshOptions {
      MaximumSidelength = %(max_sl_polygon)4f
    }
  }
  
  Circle {
    Name = "Cone"
    DomainId = 2
    Priority = 1
    Radius = %(radius_i)4f
    RefineAll = %(refine_all_circle)i
    MeshOptions {
      MaximumSidelength = %(max_sl_circle)4f
    }
  }
  
  Extrusion {
  
    LayerInterface {
	  Name = "BoundaryInterfaceBottom"
      BoundaryClass = Transparent
    }
    
    Layer {
      Name = "Subspace"
      Thickness = %(h_sub)4f
      DomainId = 1
      MeshOptions {
		MaximumSidelengthZ = %(max_sl_z_sub)4f
        MaximumSidelengthZLower = %(max_sl_z_sub)4f
        MaximumSidelengthZUpper = %(max_sl_z_slab)4f
      }
    }

    Layer {
      Name = "Slab"
      Thickness = %(h)4f
      DomainIdMapping = [1 2, 2 3]
      MeshOptions {
        MaximumSidelengthZ = %(max_sl_z_slab)4f
      }
    }
    
    LayerInterface {
	  Name = "InterfaceTop"
      GeometryValues = [Cone/Radius = %(radius_f)4f]
    }
    
    Layer {
      Name = "Superspace"
      Thickness = %(h_sup)4f
      DomainIdMapping = [1 4]
      MeshOptions {
		MaximumSidelengthZ = %(max_sl_z_sup)4f
        MaximumSidelengthZLower = %(max_sl_z_slab)4f
        MaximumSidelengthZUpper = %(max_sl_z_sup)4f
      }
    }
    
    LayerInterface {
	  Name = "BoundaryInterfaceTop"
	  GeometryValues = [Cone/Radius = %(radius_f)4f]
      BoundaryClass = Transparent
    }
  }
}